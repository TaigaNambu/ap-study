# 1. 基礎理論

## 1.1 離散数学と情報理論

### 1. 基数変換と補数
* **基数変換:** 2進数、10進数、16進数の相互変換。
    * 2進数→16進数: 4桁ごとに区切って変換する。
* **補数:** コンピュータで負の数を表現する方法。「2の補数」は、全ビットを反転（0と1を逆転）して1を加えることで求める。

### 2. 論理演算とシフト演算
* **論理積 (AND):** 両方1なら1。マスク処理（特定のビットを取り出す）に使用。
* **論理和 (OR):** どちらかが1なら1。ビットセットに使用。
* **排他的論理和 (XOR):** 異なれば1、同じなら0。暗号化やパリティチェックに使用。
* **論理シフト:** 符号なし整数の倍数・除算（左シフトで2倍、右シフトで1/2倍）。
* **算術シフト:** 符号付き整数の倍数・除算。符号ビット（最上位）を維持する。

### 3. 逆ポーランド記法
演算子を被演算子の後ろに置く表記法（例: `A + B` → `A B +`）。コンピュータが数式を処理しやすい形式。スタックを用いて計算する。

### 4. 情報量と符号化
* **ハフマン符号:** 出現頻度の高い文字には短いビット列を、低い文字には長いビット列を割り当てることで、全体のデータ量を圧縮する可変長符号化方式。

## 1.2 アルゴリズムとデータ構造

### 5. データ構造
* **スタック (Stack):** 後入れ先出し (LIFO)。`Push`（積む）と`Pop`（取り出す）。
* **キュー (Queue):** 先入れ先出し (FIFO)。`Enqueue`（入れる）と`Dequeue`（出す）。
* **リスト (Linked List):** データと次のデータへのポインタを持つ構造。挿入・削除は早いが、探索は遅い。
* **木 (Tree):** 階層構造。2分探索木では、左の子 < 親 < 右の子 の関係が成り立つ。

### 6. 探索アルゴリズム
* **2分探索法 (Binary Search):** 整列済みのデータに対して、中央値と比較して探索範囲を半分に絞り込んでいく手法。計算量は $O(\log n)$。
* **ハッシュ法:** ハッシュ関数を用いてデータの格納場所（アドレス）を直接計算する手法。計算量は $O(1)$。衝突（シノニム）対策が必要。

### 7. 整列アルゴリズム
* **クイックソート:** 基準値（ピボット）を選び、大小に分割して再帰的にソートする。平均計算量は $O(n \log n)$ で最速クラス。
* **ヒープソート:** 未整列のデータをヒープ（順序木）に構成して、最大値（または最小値）を取り出していく手法。